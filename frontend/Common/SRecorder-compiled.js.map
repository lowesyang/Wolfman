{"version":3,"sources":["SRecorder.js"],"names":[],"mappings":"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","file":"SRecorder-compiled.js","sourcesContent":["// webRTC封装SRecorder，利用分段录音来实现即时语音\r\n// SRecorder.start() 开启录音\r\n// SRecroder.getBlob() 获取录音段二进制数据\r\n\r\nlet SRecorder = function(stream) {\r\n    let config = {};\r\n    config.sampleBits = config.smapleBits || 8;\r\n    config.sampleRate = config.sampleRate || (44100 / 6);\r\n\r\n    window.URL=window.URL||window.webkitURL;\r\n    AudioContext=AudioContext||webkitAudioContext||mozAudioContext||msAudioContext;\r\n\r\n    let context = new AudioContext();\r\n    let audioInput = context.createMediaStreamSource(stream);\r\n    let recorder = context.createScriptProcessor(4096, 1, 1);\r\n\r\n    let audioData = {\r\n        size: 0,          //录音文件长度\r\n        buffer: [],     //录音缓存\r\n        inputSampleRate: context.sampleRate,    //输入采样率\r\n        inputSampleBits: 16,       //输入采样数位 8, 16\r\n        outputSampleRate: config.sampleRate,    //输出采样率\r\n        oututSampleBits: config.sampleBits,     //输出采样数位 8, 16\r\n        clear: function() {\r\n            this.buffer = [];\r\n            this.size = 0;\r\n        },\r\n        input: function (data) {\r\n            this.buffer.push(new Float32Array(data));\r\n            this.size += data.length;\r\n        },\r\n        compress: function () { //合并压缩\r\n            //合并\r\n            let data = new Float32Array(this.size);\r\n            let offset = 0;\r\n            for (let i = 0; i < this.buffer.length; i++) {\r\n                data.set(this.buffer[i], offset);\r\n                offset += this.buffer[i].length;\r\n            }\r\n            //压缩\r\n            let compression = parseInt(this.inputSampleRate / this.outputSampleRate);\r\n            let length = data.length / compression;\r\n            let result = new Float32Array(length);\r\n            let index = 0, j = 0;\r\n            while (index < length) {\r\n                result[index] = data[j];\r\n                j += compression;\r\n                index++;\r\n            }\r\n            return result;\r\n        },\r\n        encodeWAV: function () {\r\n            let sampleRate = Math.min(this.inputSampleRate, this.outputSampleRate);\r\n            let sampleBits = Math.min(this.inputSampleBits, this.oututSampleBits);\r\n            let bytes = this.compress();\r\n            let dataLength = bytes.length * (sampleBits / 8);\r\n            let buffer = new ArrayBuffer(44 + dataLength);\r\n            let data = new DataView(buffer);\r\n\r\n            let channelCount = 1;//单声道\r\n            let offset = 0;\r\n\r\n            let writeString = function (str) {\r\n                for (let i = 0; i < str.length; i++) {\r\n                    data.setUint8(offset + i, str.charCodeAt(i));\r\n                }\r\n            };\r\n\r\n            // 资源交换文件标识符\r\n            writeString('RIFF'); offset += 4;\r\n            // 下个地址开始到文件尾总字节数,即文件大小-8\r\n            data.setUint32(offset, 36 + dataLength, true); offset += 4;\r\n            // WAV文件标志\r\n            writeString('WAVE'); offset += 4;\r\n            // 波形格式标志\r\n            writeString('fmt '); offset += 4;\r\n            // 过滤字节,一般为 0x10 = 16\r\n            data.setUint32(offset, 16, true); offset += 4;\r\n            // 格式类别 (PCM形式采样数据)\r\n            data.setUint16(offset, 1, true); offset += 2;\r\n            // 通道数\r\n            data.setUint16(offset, channelCount, true); offset += 2;\r\n            // 采样率,每秒样本数,表示每个通道的播放速度\r\n            data.setUint32(offset, sampleRate, true); offset += 4;\r\n            // 波形数据传输率 (每秒平均字节数) 单声道×每秒数据位数×每样本数据位/8\r\n            data.setUint32(offset, channelCount * sampleRate * (sampleBits / 8), true); offset += 4;\r\n            // 快数据调整数 采样一次占用字节数 单声道×每样本的数据位数/8\r\n            data.setUint16(offset, channelCount * (sampleBits / 8), true); offset += 2;\r\n            // 每样本数据位数\r\n            data.setUint16(offset, sampleBits, true); offset += 2;\r\n            // 数据标识符\r\n            writeString('data'); offset += 4;\r\n            // 采样数据总数,即数据总大小-44\r\n            data.setUint32(offset, dataLength, true); offset += 4;\r\n            // 写入采样数据\r\n            if (sampleBits === 8) {\r\n                for (let i = 0; i < bytes.length; i++, offset++) {\r\n                    let s = Math.max(-1, Math.min(1, bytes[i]));\r\n                    let val = s < 0 ? s * 0x8000 : s * 0x7FFF;\r\n                    val = parseInt(255 / (65535 / (val + 32768)));\r\n                    data.setInt8(offset, val, true);\r\n                }\r\n            } else {\r\n                for (let i = 0; i < bytes.length; i++, offset += 2) {\r\n                    let s = Math.max(-1, Math.min(1, bytes[i]));\r\n                    data.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\r\n                }\r\n            }\r\n\r\n            return new Blob([data], { type: 'audio/wav' });\r\n        }\r\n    };\r\n\r\n    this.start = function () {\r\n        audioInput.connect(recorder);\r\n        recorder.connect(context.destination);\r\n    }\r\n\r\n    this.stop = function () {\r\n        recorder.disconnect();\r\n    }\r\n\r\n    this.getBlob = function () {\r\n        return audioData.encodeWAV();\r\n    }\r\n\r\n    this.clear = function() {\r\n        audioData.clear();\r\n    }\r\n\r\n    recorder.onaudioprocess = function (e) {\r\n        audioData.input(e.inputBuffer.getChannelData(0));\r\n    }\r\n};\r\n\r\nexport default SRecorder;"]}